
connect()

함수포인터

int (*fp)(int,int);



int func1(int a,int b);
...

//이런식으로 쓰이는 것으로부터, 함수의 이름이 곧 함수의 포인터 라는것을 명심해라.
//포인터 주소로 가면 어디로갈까요?=> .text 세그먼트로 갑니다.
fp = func1;




함수시그니쳐 
    컴파일러가 함수간 구분을 하기 위해 필요한 최소 정보들
    즉, 함수 이름(매개변수 타입목록)



1. 정석 오버로딩
    - 첫번째 인자 : sender(ex:QPushButton &객체)의 참조.(&참조자 or *포인터)
    - 두번째 인자 : Signal -> (ex: SIGNAL(clicked())))
    - 세번째 인자 : 리시버 this
    - 네번째 인자 : 리시버가 가지고있는 SLOT.

----
2. 람다(1번째 3번째 호기심이 여기 해당)함수 쓰는 오버로딩.
    1번 방식의 귀차니즘 몇가지 - 헤더에 public slots: 해야지, cpp 에 구현해야지, 귀찮다.

    - 첫번째 인자 : 정석방식과 동일
    - 두번째 인자 : &클래스이름::시그널함수이름(=>함수포인터)
    - 세번째 인자 : 람다 함수로 기술된 SLOT.





-------

이놈 소속은 소속이라. 애지간한 데서는 쓸수 있

qDebug()<<"하고싶은말";

ㄴ> 요래 쓰시면, 디버그창에 문구 쏴준다. 할말.


------

매개변수를 쓰는 시그널과 슬롯

------
강사님의 한마디 : 위젯 구성 기본

"Parent 에 속한 Child 위젯들은, 무조껀 포인터에 동적할당 해줘야 해."

"안그럼 Parent 생성자 종료될때 날라가. 해봐~"

------
sender()

connect 의 네번째 parameter 였던 SLOT 함수, sender() 로 뭔가 불러올 수 있는데
=>무엇이냐? 바로 같이 connect 된 명령문의 첫번째 매개변수에 있던, 
    "Signal 을 발생시킨 주체" 이더라.







